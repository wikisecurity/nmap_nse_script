local http = require "http"
local shortport = require "shortport"
local stdnse = require "stdnse"
local string = require "string"
local math = require "math"
local table = require "table"

description = [[
Checks for a known web-compromise behavior pattern using a baseline 404 test and
a probe request to a suspicious path (/ts/in.cgi?open2=1). Reports result as
CLEAN / SUSPECT / INCONCLUSIVE along with evidence.

Design goals:
- Prefer -sV (service detection) so HTTP-like services are matched correctly
- Conservative result classification to reduce false positives
]]

author = "WIKI Security Lab(Improving false positives in existing http-malware-host.nse)"
license = "Same as Nmap--See https://nmap.org/book/man-legal.html"
categories = {"discovery", "safe"}

-- Portrule:
-- - Prefer services that Nmap identifies as HTTP-like (requires -sV for best results)
-- - Also allow SSL-tunneled ports that are likely HTTPS
portrule = function(host, port)
  if port.protocol ~= "tcp" then
    return false
  end

  -- Best-effort: Nmap's built-in http matcher
  if shortport.http(host, port) then
    return true
  end

  -- Some services might not match shortport.http but are clearly http-ish by name
  if port.service and (port.service:match("^http") or port.service:match("^https")) then
    return true
  end

  -- If service tunnel is SSL and port is open, it can still be an HTTPS service
  if port.tunnel == "ssl" or (port.version and port.version.service_tunnel == "ssl") then
    return true
  end

  return false
end

local function rand_suffix(len)
  len = len or 12
  local chars = "abcdefghijklmnopqrstuvwxyz0123456789"
  local out = {}
  for i = 1, len do
    local idx = math.random(#chars)
    out[#out + 1] = chars:sub(idx, idx)
  end
  return table.concat(out)
end

local function fmt_ev(k, v)
  return string.format("- %s: %s", k, v)
end

local function safe_status(resp)
  if not resp then return nil end
  return resp.status
end

local function header_location(resp)
  if not resp or not resp.header then return nil end
  -- http.lua typically normalizes header keys to lower-case
  return resp.header["location"] or resp.header["Location"]
end

local function is_redirect(code)
  return code == 301 or code == 302 or code == 303 or code == 307 or code == 308
end

action = function(host, port)
  math.randomseed(os.time() + (port.number or 0))

  local evidence = {}

  -- Do NOT follow redirects. We want raw behavior (especially 3xx).
  local opts = {
    redirect_ok = false,
    no_cache = true,
    header = {
      ["User-Agent"] = "Nmap NSE http-malware-host-1",
      ["Connection"] = "close"
    }
  }

  -- Baseline: random nonexistent path should return 404 on a "normal" site
  local baseline_path = "/nmapmalwarecheck-" .. rand_suffix(10)
  local base_resp = http.get(host, port, baseline_path, opts)
  local base_status = safe_status(base_resp)
  local base_loc = header_location(base_resp)

  evidence[#evidence + 1] = fmt_ev("baseline_path", baseline_path)
  evidence[#evidence + 1] = fmt_ev("baseline_status", tostring(base_status or "nil"))
  if base_loc then
    evidence[#evidence + 1] = fmt_ev("baseline_location", base_loc)
  end

  -- Probe: known suspicious path used by legacy malware-host checks
  local probe_path = "/ts/in.cgi?open2=1"
  local probe_resp = http.get(host, port, probe_path, opts)
  local probe_status = safe_status(probe_resp)
  local probe_loc = header_location(probe_resp)

  evidence[#evidence + 1] = fmt_ev("probe_path", probe_path)
  evidence[#evidence + 1] = fmt_ev("probe_status", tostring(probe_status or "nil"))
  if probe_loc then
    evidence[#evidence + 1] = fmt_ev("probe_location", probe_loc)
  end

  -- Classification (conservative):
  -- CLEAN:
  --   baseline == 404 AND probe == 404
  -- SUSPECT:
  --   baseline == 404 AND probe is a redirect (3xx with Location)
  -- INCONCLUSIVE:
  --   anything else (e.g., baseline not 404, both redirect, unusual 4xx/5xx, WAF behavior, forced redirects, etc.)

  local result = "INCONCLUSIVE"
  local reason = ""

  if base_status == 404 and probe_status == 404 then
    result = "CLEAN"
    reason = "Both baseline and probe returned 404"
  elseif base_status == 404 and is_redirect(probe_status) and probe_loc then
    result = "SUSPECT"
    reason = "Baseline returned 404, but probe triggered redirect behavior"
  else
    -- Helpful reason hints for common confusing cases
    if base_status and is_redirect(base_status) then
      reason = "Baseline for unknown path did not return 404 (site forces redirects), unable to confidently check"
    elseif base_status == 400 then
      reason = "Baseline returned 400 (possible Host header / virtual host / proxy behavior), unable to confidently check"
    elseif probe_status and is_redirect(probe_status) and not probe_loc then
      reason = "Probe returned redirect status without Location header, unable to confidently check"
    else
      reason = "Observed behavior does not match clean or strong suspicious pattern"
    end
  end

  local lines = {}
  lines[#lines + 1] = "RESULT: " .. result
  lines[#lines + 1] = "REASON: " .. reason
  lines[#lines + 1] = "EVIDENCE:"
  for _, ev in ipairs(evidence) do
    lines[#lines + 1] = ev
  end

  return table.concat(lines, "\n")
end

