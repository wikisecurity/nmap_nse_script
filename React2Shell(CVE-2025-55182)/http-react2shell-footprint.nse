local http      = require "http"
local shortport = require "shortport"
local stdnse    = require "stdnse"
local string    = require "string"
local table     = require "table"

description = [[
Non-destructive unauthenticated footprint check for Next.js / React Server Components (RSC)
that may indicate exposure related to React2Shell (CVE-2025-55182).

- Runs on ANY port detected as http/https (port-agnostic)
- Follows limited redirects (default: 2)
- Supports virtual host via --script-args http.host=<hostname>
- Limits response body size (default: 200KB) to avoid slow scans
- Outputs evidence-based scoring (POSSIBLE/INCONCLUSIVE/NOT_DETECTED)
- Does NOT attempt exploitation
]]

author = "WIKI Security Lab (NSE template)"
license = "Same as Nmap--See https://nmap.org/book/man-legal.html"
categories = {"safe", "discovery", "version"}

portrule = function(host, port)
  return shortport.service({"http","https"})(host, port)
end

-- ----------------------------
-- Helpers
-- ----------------------------
local function to_int(v, default)
  local n = tonumber(v)
  if n == nil then return default end
  return n
end

local function lower(s)
  if not s then return "" end
  return string.lower(s)
end

local function hdr_get(headers, name)
  if not headers then return nil end
  local want = lower(name)
  for k, v in pairs(headers) do
    if lower(k) == want then
      return v
    end
  end
  return nil
end

local function add_evidence(ev, item)
  ev[#ev + 1] = item
end

local function body_truncate(body, max_bytes)
  if not body then return "" end
  if #body <= max_bytes then return body end
  return string.sub(body, 1, max_bytes)
end

local function is_redirect_status(st)
  return st == 301 or st == 302 or st == 303 or st == 307 or st == 308
end

local function normalize_location(loc, current_path)
  -- If Location is absolute URL, http library may or may not accept it in path.
  -- Keep it simple: if it starts with "http", try extracting path.
  if not loc or loc == "" then return nil end
  if string.sub(loc, 1, 4) == "http" then
    -- crude parse: find "://" then next "/" for path
    local p = string.find(loc, "://", 1, true)
    if not p then return nil end
    local slash = string.find(loc, "/", p + 3, true)
    if not slash then return "/" end
    return string.sub(loc, slash)
  end

  -- If relative path without leading slash, resolve against directory of current_path
  if string.sub(loc, 1, 1) ~= "/" then
    local dir = "/"
    if current_path and current_path ~= "" then
      local last_slash = string.find(current_path, "/[^/]*$")
      if last_slash then
        dir = string.sub(current_path, 1, last_slash)
      end
    end
    return dir .. loc
  end

  return loc
end

-- ----------------------------
-- HTTP fetch with:
-- - Host header support
-- - limited redirects
-- - body size limit
-- ----------------------------
local function safe_fetch(host, port, path, method, cfg, trace)
  local opts = {
    bypass_cache = true,
    header = {
      ["User-Agent"] = cfg.ua
    }
  }

  if cfg.vhost and cfg.vhost ~= "" then
    opts.header["Host"] = cfg.vhost
  end

  local current_path = path
  local depth = 0

  while true do
    local r
    if method == "HEAD" then
      r = http.head(host, port, current_path, opts)
    else
      r = http.get(host, port, current_path, opts)
    end

    if not r then
      add_evidence(trace, {
        type="request",
        path=current_path,
        method=method,
        status="NO_RESPONSE"
      })
      return nil
    end

    local st = to_int(r.status, 0)
    local loc = hdr_get(r.header, "location")
    add_evidence(trace, {
      type="request",
      path=current_path,
      method=method,
      status=st,
      location=loc
    })

    -- If GET, truncate body
    if r.body and cfg.max_body_bytes and cfg.max_body_bytes > 0 then
      r.body = body_truncate(r.body, cfg.max_body_bytes)
    end

    if is_redirect_status(st) and loc and depth < cfg.max_redirects then
      local next_path = normalize_location(loc, current_path)
      if not next_path or next_path == current_path then
        return r
      end
      depth = depth + 1
      current_path = next_path
      -- continue loop
    else
      return r
    end
  end
end

-- ----------------------------
-- Signature checks
-- ----------------------------
local function contains_any(hay, needles)
  if not hay or hay == "" then return nil end
  for _, n in ipairs(needles) do
    if n and n ~= "" then
      if string.find(hay, n, 1, true) then
        return n
      end
    end
  end
  return nil
end

-- ----------------------------
-- Action
-- ----------------------------
action = function(host, port)
  -- Script args
  local cfg = {
    vhost          = stdnse.get_script_args("http.host") or "",
    ua             = stdnse.get_script_args("http.useragent") or "Mozilla/5.0 (Nmap NSE)",
    max_redirects  = to_int(stdnse.get_script_args("react2shell.max_redirects"), 2),
    max_body_bytes = to_int(stdnse.get_script_args("react2shell.max_body_bytes"), 200 * 1024),
    -- scoring thresholds
    th_strong      = to_int(stdnse.get_script_args("react2shell.th_strong"), 8),
    th_moderate    = to_int(stdnse.get_script_args("react2shell.th_moderate"), 5),
    th_weak        = to_int(stdnse.get_script_args("react2shell.th_weak"), 1),
  }

  -- Target paths to probe (expandable)
  local probe_paths = {
    "/", "/login", "/signin", "/admin", "/index.html", "/robots.txt"
  }

  -- Next.js static-ish paths
  local next_paths = {
    "/_next/static/", "/_next/", "/_next/image"
  }

  local evidence = {}
  local trace = {}

  local score = 0
  local matched = {
    next_ref_in_html = false,
    next_data_marker = false,
    next_static_reachable = false,
    next_header_hint = false,
    rsc_content_type = false,
    nextjs_headers = {}
  }

  -- Signature tokens (customizable)
  local html_tokens = {
    "/_next/", "__NEXT_DATA__", "next-route-announcer", "id=\"__next\"", "data-nextjs"
  }

  local next_headers = {
    "x-nextjs-cache", "x-nextjs-page", "x-nextjs-matched-path", "x-nextjs-redirect",
    "x-nextjs-data", "x-nextjs-router-state-tree"
  }

  -- 1) Probe common paths to collect HTML hints
  local best_root = nil
  for _, p in ipairs(probe_paths) do
    local r = safe_fetch(host, port, p, "GET", cfg, trace)
    if r and r.status then
      local st = to_int(r.status, 0)
      local headers = r.header or {}
      local body = r.body or ""

      -- collect Next.js-related headers as evidence (bonus)
      for _, hn in ipairs(next_headers) do
        local hv = hdr_get(headers, hn)
        if hv and hv ~= "" then
          matched.nextjs_headers[hn] = hv
        end
      end

      -- x-powered-by hint
      local xpb = hdr_get(headers, "x-powered-by")
      if xpb and string.find(lower(xpb), "next", 1, true) then
        if not matched.next_header_hint then
          score = score + 1
          matched.next_header_hint = true
          add_evidence(evidence, {key="x-powered-by", value=xpb, weight=1, note="Header suggests Next.js"})
        end
      end

      -- content-type hint for RSC
      local ctype = hdr_get(headers, "content-type") or ""
      if (ctype ~= "") and string.find(lower(ctype), "text/x%-component") then
        if not matched.rsc_content_type then
          score = score + 3
          matched.rsc_content_type = true
          add_evidence(evidence, {key="content-type", value=ctype, weight=3, note="Observed RSC content-type"})
        end
      end

      -- HTML token checks (truncate already applied)
      local hit = contains_any(body, html_tokens)
      if hit then
        -- specifically /_next/ reference
        if hit == "/_next/" and not matched.next_ref_in_html then
          score = score + 2
          matched.next_ref_in_html = true
          add_evidence(evidence, {key="html", value="/_next/ found", weight=2, note="Found '/_next/' reference in response body", path=p})
        end
        -- __NEXT_DATA__ marker
        if hit == "__NEXT_DATA__" and not matched.next_data_marker then
          score = score + 2
          matched.next_data_marker = true
          add_evidence(evidence, {key="html", value="__NEXT_DATA__ found", weight=2, note="Found '__NEXT_DATA__' marker in response body", path=p})
        end
        -- other tokens: smaller bonus
        if hit ~= "/_next/" and hit ~= "__NEXT_DATA__" then
          score = score + 1
          add_evidence(evidence, {key="html", value=hit .. " found", weight=1, note="Next.js/React-related token observed", path=p})
        end
      end

      -- pick best candidate page (prefer 200)
      if not best_root then
        best_root = r
      elseif to_int(best_root.status,0) ~= 200 and st == 200 then
        best_root = r
      end
    end
  end

  -- if any nextjs headers found, add as evidence
  for hn, hv in pairs(matched.nextjs_headers) do
    score = score + 1
    add_evidence(evidence, {key=hn, value=hv, weight=1, note="Next.js-related response header observed"})
  end

  -- 2) Probe Next.js static endpoints
  for _, np in ipairs(next_paths) do
    local r2 = safe_fetch(host, port, np, "GET", cfg, trace)
    if r2 and r2.status then
      local st2 = to_int(r2.status, 0)
      local ct2 = hdr_get(r2.header, "content-type") or ""

      -- treat 2xx/3xx/403 as "present"
      if (st2 >= 200 and st2 < 400) or st2 == 403 then
        if not matched.next_static_reachable then
          score = score + 2
          matched.next_static_reachable = true
          add_evidence(evidence, {key="path", value=np, weight=2, note="Next.js path appears present (status " .. st2 .. ")"})
        else
          -- add light evidence for additional endpoints
          score = score + 1
          add_evidence(evidence, {key="path", value=np, weight=1, note="Additional Next.js path responded (status " .. st2 .. ")"})
        end
      else
        add_evidence(evidence, {key="path", value=np, weight=0, note="Next.js path check returned status " .. st2})
      end

      -- RSC content type on these endpoints (rare but strong)
      if (ct2 ~= "") and string.find(lower(ct2), "text/x%-component") then
        if not matched.rsc_content_type then
          score = score + 3
          matched.rsc_content_type = true
          add_evidence(evidence, {key="content-type", value=ct2, weight=3, note="Observed RSC content-type on " .. np})
        end
      end
    else
      add_evidence(evidence, {key="path", value=np, weight=0, note="No response from Next.js path"})
    end
  end

  -- Verdict (avoid overstating "vulnerable" without version/exploit)
  local verdict
  if score >= cfg.th_strong then
    verdict = "POSSIBLE (strong Next.js/RSC footprint)"
  elseif score >= cfg.th_moderate then
    verdict = "POSSIBLE (moderate footprint)"
  elseif score >= cfg.th_weak then
    verdict = "INCONCLUSIVE (weak footprint)"
  else
    verdict = "NOT_DETECTED"
  end

  -- Output
  local out = {}
  out[#out+1] = verdict
  out[#out+1] = "score=" .. score
  if cfg.vhost and cfg.vhost ~= "" then
    out[#out+1] = "vhost=" .. cfg.vhost
  end
  out[#out+1] = "limits: max_redirects=" .. cfg.max_redirects .. ", max_body_bytes=" .. cfg.max_body_bytes

  if #evidence > 0 then
    out[#out+1] = "evidence:"
    table.sort(evidence, function(a,b) return (a.weight or 0) > (b.weight or 0) end)
    for _, e in ipairs(evidence) do
      local line = string.format("  - (+%d) %s: %s", to_int(e.weight,0), e.key or "info", e.value or "")
      if e.note and e.note ~= "" then
        line = line .. " | " .. e.note
      end
      if e.path and e.path ~= "" then
        line = line .. " | path=" .. e.path
      end
      out[#out+1] = line
    end
  end

  -- request trace (optional toggle via script arg)
  local show_trace = stdnse.get_script_args("react2shell.show_trace")
  if show_trace and tostring(show_trace) == "1" then
    out[#out+1] = "trace:"
    for _, t in ipairs(trace) do
      local loc = t.location and (" location=" .. t.location) or ""
      out[#out+1] = string.format("  - %s %s => %s%s", t.method or "GET", t.path or "", tostring(t.status or ""), loc)
    end
  end

  out[#out+1] = "note: This is a footprint/exposure check only. Patch/mitigate if service is confirmed affected."

  return stdnse.format_output(true, out)
end
